#! /usr/bin/env python
# coding: utf-8


"""TODO"""


import argparse
import concurrent.futures
import json
import logging as log
import os

import bcrypt
import mysql.connector
import RPi.GPIO as GPIO
import tornado.escape
import tornado.httpserver
import tornado.ioloop
import tornado.web
import tornado.websocket
from tornado import gen

from sensor.ultrasonic import UltrasonicSensor
from relay.relay import Relay


# define("port", default=9080, help="run on the given port", type=int)
# define("mysql_host", default="127.0.0.1:3306", help="blog database host")
# define("mysql_database", default="openpluie", help="blog database name")
# define("mysql_user", default="eloi", help="blog database user")
# define("mysql_password", default="openpluie", help="blog database password") # TODO WARNING here

# Define log file
log.basicConfig(filename='server.log', format='%(asctime)s %(message)s', level=log.DEBUG)

# A thread pool to be used for password hashing with bcrypt.
executor = concurrent.futures.ThreadPoolExecutor(2)


# pins = [int(pin) for id, pin in all_pins["relay"].items()]

# loop through pins and set mode and state to "high"
# GPIO.setmode(GPIO.BCM) # TODO in decorator
# for i in pins:
#    GPIO.setup(i, GPIO.OUT)
#    GPIO.output(i, GPIO.HIGH)


def parse_args():
    """Command line parser."""
    parser = argparse.ArgumentParser()

    # Server
    server = parser.add_argument_group("Server.")
    server.add_argument("--port", type=int, default=9080,
        help="Port to run the server on (default: 9080)")

    # Raspberry
    rpi = parser.add_argument_group("Raspberry.")
    rpi.add_argument("--pinconfig", type=str, default="./config/pins.json",
        help="Path to the pins configuration file (default: './config/pins.json').")
    rpi.add_argument("--temperature", type=int, default=20,
        help="Temperaturen in Celsius, to compute sound speed (default: 20°C).")

    # Database
    db = parser.add_argument_group("SQL Database.")
    db.add_argument("--sqlhost", default="127.0.0.1",
        help="Database host (default: 127.0.0.1)."),
    db.add_argument("--sqlport", type=int, default=3306,
        help="Database port.")
    db.add_argument("--sqldb", default="openpluie",
        help="Database name (default: 'openpluie').")
    db.add_argument("--sqluser", default="eloi",
        help="Database user (default: 'eloi').")
    db.add_argument("--sqlpwd", required=True, type=str,
        help="Database password.")

    return parser.parse_args()


def load_pin_config(path):
    """Load the pin config file and check it"""
    with open(path, "r") as f:
        pins = json.load(f)
    assert sorted(pins.keys()) == ["relay", "trigger", "echo"]
    return pins


def admin(method):
    """Decorator.
    Require that the user is logged in as an admin."""
    @tornado.web.authenticated
    def wrapper(self, *args, **kwargs):
        if not self.user_is_admin():
            raise tornado.web.HTTPError(403)("Denied: you are not admin.")
        return method(self, *args, **kwargs)
    return wrapper


def gpio(function):
    """Decorator.
        - Set mode to GPIO.BCM
        - Call GPIO.cleanup if an exception is raised (or if ctrl+c)
    """
    def gpio_function():
        GPIO.setmode(GPIO.BCM)
        try:
            function()
        except KeyboardInterrupt:
            log.warning("\nInterruption from user.")
        except Exception as e:
            log.critical(e)
        finally:
            log.info("Cleaning GPIO.")
            GPIO.cleanup()
    return gpio_function


class Application(tornado.web.Application):
    def __init__(self, sql_config):
        """TODO"""
        handlers = [
            (r"/", HomeHandler),
            (r'/ws', WSHandler),
            (r"/auth/create", AuthCreateHandler),
            (r"/auth/login", AuthLoginHandler),
            (r"/auth/logout", AuthLogoutHandler),
        ]

        settings = dict(
            page_title="OpenPluie",
            template_path=os.path.join(os.path.dirname(__file__), "templates"),
            static_path=os.path.join(os.path.dirname(__file__), "static"),
            xsrf_cookies=True,
            cookie_secret="iuev1456yih5678kvje78on", # TODO warning here
            login_url="/auth/login",
            debug=True,
        )

        super(Application, self).__init__(handlers, **settings)

        # Have one global connection to the database across all handlers
        self.database = mysql.connector.connect(
            host=sql_config["host"],
            port=sql_config["port"],
            database=sql_config["database"],
            user=sql_config["user"],
            password=sql_config["password"]
        )
        self.cursor = self.database.cursor()

        # host="127.0.0.1",
        # database="openpluie",
        # port=3306,
        # user="eloi",
        # passwd="openpluie"
        # )

        # self.db = torndb.Connection()

        # manage gpio state TODO wtf ??
        self.gpio_state = [False] * len(pins) # TODO


class BaseHandler(tornado.web.RequestHandler):
    """TODO"""
    @property
    def db(self):
        return self.application.db

    @property
    def gpio_state(self):
        return self.application.gpio_state

    def get_current_user(self):
        user_id = self.get_secure_cookie("user")
        if not user_id:
            return None
        self.cursor.execute("SELECT * FROM users WHERE id = %s", int(user_id))
        return self.cursor.fetchone()
        # return self.db.get("SELECT * FROM users WHERE id = %s", int(user_id))

    def any_user_exists(self):
        self.cursor.execute("SELECT * FROM users LIMIT 1")
        return bool(self.cursor.fetchall())
        # return bool(self.db.get("SELECT * FROM users LIMIT 1"))

    def user_is_admin(self):
        user = self.get_current_user()
        if user:
            return user.username == 'admin' and user.first_name == "Eloi" and user.last_name == "Alonso"
        return False


class HomeHandler(BaseHandler):
    """TODO"""
    @tornado.web.authenticated # this decorator redirects the user the login_url if he is not authenticated
    def get(self):
        log.info("[HTTP](MainHandler) {} connected.".format(self.get_current_user().username))
        # print >> log_file, "[HTTP](MainHandler) {} connected.".format(self.get_current_user().username)
        # name = tornado.escape.xhtml_escape(self.current_user)
        # self.write("Hello, " + name)
        self.render("home.html", admin=self.user_is_admin(), gpio_state=self.gpio_state)


class AuthCreateHandler(BaseHandler):
    """TODO"""
    @admin
    def get(self):
        self.render("create_user.html", admin=self.user_is_admin(), error=None)

    @gen.coroutine
    def post(self):
        hashed_password = yield executor.submit(
            bcrypt.hashpw, tornado.escape.utf8(self.get_argument("password")),
            bcrypt.gensalt())
        hashed_password2 = yield executor.submit(
            bcrypt.hashpw, tornado.escape.utf8(self.get_argument("password2")),
            bcrypt.gensalt())
        username = self.get_argument("username")
        # if bool(self.db.get("SELECT * FROM users WHERE username = %s", username)):
        self.cursor.execute("SELECT * FROM users WHERE username = %s", username)
        if bool(self.cursor.fetchall()):
            # raise tornado.web.HTTPError(400, "user already created, please choose another username.")
            self.render("create_user.html", error="user already created, please choose another username.")
            return
        if self.get_argument("password") != self.get_argument("password2"):
            self.render("create_user.html", error="Passwords are different.")
            return

        # insert query
        sql = "INSERT INTO users (username, first_name, last_name, hashed_password) VALUES (%s, %s, %s, %s)"
        val = (username, self.get_argument("first_name"), self.get_argument("last_name"), hashed_password)
        self.cursor.execute(sql, val)
        self.database.commit()
        # user_id = self.db.execute(
        #    "INSERT INTO users (username, first_name, last_name, hashed_password) "
        #    "VALUES ({}, {}, {}, {})".format(username, self.get_argument("first_name"),
        #    self.get_argument("last_name"), hashed_password))

        self.redirect(self.get_argument("next", "/"))



class AuthLoginHandler(BaseHandler):
    """TODO"""
    def get(self):
        self.render("login.html", error=None)

    @gen.coroutine
    def post(self):
        self.cursor.execute("SELECT * FROM users WHERE username = %s", self.get_argument("username"))
        user = self.cursor.fetchone()
        # user = self.db.get("SELECT * FROM users WHERE username = %s", self.get_argument("username"))
        if not user:
            self.render("login.html", error="username not found")
            return
        hashed_password = yield executor.submit(
            bcrypt.hashpw, tornado.escape.utf8(self.get_argument("password")),
            tornado.escape.utf8(user.hashed_password))
        if hashed_password == user.hashed_password:
            self.set_secure_cookie("user", str(user.id), expires_days=None)
            self.redirect(self.get_argument("next", "/"))
        else:
            self.render("login.html", error="incorrect password")


class AuthLogoutHandler(BaseHandler):
    """TODO"""
    @tornado.web.authenticated
    def get(self):
        self.clear_cookie("user")
        self.redirect(self.get_argument("next", "/"))

class WSHandler(tornado.websocket.WebSocketHandler):
    """ handles web sockets """
    def open(self):
        user_id = self.get_secure_cookie("user")
        if not user_id:
            return None
        log.info('[WS] Connection was opened.')
        # print >> log_file, '[WS] Connection was opened.'

    def on_message(self, message):
        log.info('[WS] Incoming message: {}'.format(message))
        # print >> log_file, '[WS] Incoming message: {}'.format(message)
        log.info('[App] GPIO states : {} '.format(self.application.gpio_state))
        # print >> log_file, '[App] GPIO states : {} '.format(self.application.gpio_state)
        if message == "slider1_on":
            self.application.gpio_state[0] = True
            GPIO.output(pins[0], GPIO.LOW)
        elif message == "slider1_off":
            self.application.gpio_state[0] = False
            GPIO.output(pins[0], GPIO.HIGH)
        elif message == "slider2_on":
            self.application.gpio_state[1] = True
            GPIO.output(pins[1], GPIO.LOW)
        elif message == "slider2_off":
            self.application.gpio_state[1] = False
            GPIO.output(pins[1], GPIO.HIGH)
        else:
            raise tornado.web.HTTPError(404)("Unknown WS message.")


    def on_close(self):
        log.info('[WS] Connection was closed.')
        # print >> log_file, '[WS] Connection was closed.'


@gpio
def main():
    import pdb; pdb.set_trace()
    # Parse command line
    args = parse_args()

    # Load pin config file
    pins = load_pin_config(args.pinconfig)

    # Create ultrasonic sensor
    sensor = UltrasonicSensor(trig=pins["trigger"],
                              echo=pins["echo"],
                              temperature=args.temperature)

    # Create relays
    relays = {}
    for id, pin in pins["relay"].items():
        if pin is None:
            log.warning("Relay n°{} is not available (according to the pin config file)".format(id))
            relays[int(id)] = None
            continue
        relays[int(id)] = Relay(pin)

    # Database config
    sql_config = {"host": args.sqlhost, "port": args.sqlport, "database": args.sqlhost, "user": args.sqluser, "password": args.sqlpwd}

    try:
        # tornado.options.parse_command_line()
        app = Application(sql_config)
        http_server = tornado.httpserver.HTTPServer(app)
        http_server.listen(args.port)
        main_loop = tornado.ioloop.IOLoop.instance()
        log.info("Tornado Server started on port {}".format(args.port))
        main_loop.start()

    except KeyboardInterrupt:
        log.warning("Stopped by user.")

    except Exception as e:
        log.critical(e)

        # for i in pins:
        #        GPIO.setup(i, GPIO.OUT)
        #        GPIO.output(i, GPIO.HIGH)
        # GPIO.cleanup()
        # # log_file.close()


if __name__ == "__main__":
    main()




